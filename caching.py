# -*- coding: utf-8 -*-
"""Caching

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oXrYK3-WMpEzH_ge6Ki7Q_HBNnBicYcF
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from numpy import random
import matplotlib.pyplot as plt
# %matplotlib inline

from google.colab import drive
drive.mount('/content/drive')

N = 100 # total ids 
pi = 3.14

"""LRU"""

def LRU(y, x, request_time,con):
  [N,I] = x.shape
  J = len(y)
  old = y.reshape(J*N).copy()
  for j in range(J):
    x_t_j = np.zeros((N),int)
    file_req_time = np.zeros((N),int)

    # to find which users are connected to this cache 
    connected_users = np.where(con[:,j]==1)[0]
    for k in range(len(connected_users)):
      x_t_j += x[:,connected_users[k]]
      file_req_time = np.maximum(file_req_time, request_time[:,connected_users[k]])
    x_t_j = np.minimum(np.ones(N),x_t_j)

    # file which is not requested but still in the cache
    a1 = np.transpose(np.logical_and(y[j],np.logical_not(np.logical_and(y[j],np.transpose(x_t_j)))))
    a = np.where(a1 == 1)[0]
    # file requested but not in the cache.
    b1 = np.transpose(np.logical_and(np.transpose(x_t_j),np.logical_not(np.logical_and(y[j],np.transpose(x_t_j))))) 
    b = np.where(b1 == 1)[0]

    if len(a)>0 and len(b)>0:
      if len(a)>len(b):
        t = np.zeros(len(a))
        for k in range(len(a)):
          t[k] = file_req_time[a[k]]
        replace = (t).argsort()[:len(b)]
        for k in range(len(b)):
          y[j,a[int(replace[k])]] = 0
        for k in range(len(b)):
            y[j,b[k]] = 1
      
      else:
        t = np.zeros(len(b))
        for k in range(len(b)):
          t[k] = file_req_time[b[k]]
        replace = (t).argsort()[:len(a)]
        for k in range(len(a)):
          y[j,b[int(replace[k])]] = 1
        for k in range(len(a)):
          y[j,a[k]] = 0
  new = y.reshape(J*N)
  download = np.sum(np.logical_and(new,np.logical_not(old)))
  return y,download

"""LFU"""

def LFU(y,x,freq,con):
  [N,I] = x.shape
  J = len(y)
  old = y.reshape(J*N).copy()
  for j in range(J):
    file_freq = np.zeros((N),int)
    x_t_j = np.zeros((N),int)

    # to find which users are connected to this cache 
    connected_users = np.where(con[:,j]==1)[0]
    for k in range(len(connected_users)):
      x_t_j += x[:,connected_users[k]]
      file_freq += freq[:,connected_users[k]]
    x_t_j = np.minimum(np.ones(N),x_t_j)

    # file which is not requested but still in the cache
    a1 = np.transpose(np.logical_and(y[j],np.logical_not(np.logical_and(y[j],np.transpose(x_t_j)))))
    a = np.where(a1 == 1)[0]
    # file requested but not in the cache.
    b1 = np.transpose(np.logical_and(np.transpose(x_t_j),np.logical_not(np.logical_and(y[j],np.transpose(x_t_j))))) 
    b = np.where(b1 == 1)[0]

    if len(a)>0 and len(b)>0:
      if len(a)>len(b):
        t = np.zeros(len(a))
        for k in range(len(a)):
          t[k] = file_freq[a[k]]
        replace = (t).argsort()[:len(b)]
        for k in range(len(b)):
          y[j,a[int(replace[k])]] = 0
        for k in range(len(b)):
            y[j,b[k]] = 1
      
      else:
        t = np.zeros(len(b))
        for k in range(len(b)):
          t[k] = file_freq[b[k]]
        replace = (t).argsort()[:len(a)]
        for k in range(len(a)):
          y[j,b[int(replace[k])]] = 1
        for k in range(len(a)):
          y[j,a[k]] = 0
  new = y.reshape(J*N)
  download = np.sum(np.logical_and(new,np.logical_not(old)))
  return y,download

"""perturbed count"""

def per_count(eta,count,normal_dist):
  [N,I] = count.shape
  p_count = np.zeros((N,I),dtype = 'f4')
  for i in range(I):
    p_count[:,i] = count[:,i] + np.round(np.multiply(eta, normal_dist[:,i]).reshape(N),4)
  return p_count

"""GREEDY"""

def Greedy(con,count):
  [I,J] = con.shape
  [N,I] = count.shape
  load = np.zeros((1,J),dtype = int)

  for i in range(I):
    for f in range(N):
      if count[f,i] < 0:
        count[f,i] = 0
  
  loadc = 0
  y = np.zeros((J,N),dtype = int)
  z = np.zeros((I,N),dtype = 'f4')
  mark = np.zeros((I,N),dtype = int)

  while(loadc < J):
    best_cache = -1
    best_file = -1
    best_imp = -1

    for j in range(J):
      if load[0,j] < C:
        for f in range(N):
          if y[j,f] != 1:
            imp = 0

            for i in range(I):
              if con[i,j] == 1 and mark[i,f] == 0:
                imp += count[f,i]

            if imp >= best_imp:
              best_cache = j
              best_file = f
              best_imp = imp

    y[best_cache,best_file] = 1

    for i in range(I):
      if con[i,best_cache] == 1:
        mark[i,best_file] = 1

    load[0,best_cache] += 1
    if load[0,best_cache] == C:
      loadc += 1
  
  for i in range(I):
    for f in range(N):
      for j in range(J):
        if con[i,j] == 1:
          z[i,f] = np.maximum(y[j,f],z[i,f])
      
  return y,z

"""MARKER"""

def Marker(y,x,bit,con,phase):
  [N,I] = x.shape
  J = len(y)
  old = y.reshape(J*N).copy()
  
  for j in range(J):
    x_t_j = np.zeros((N),int)
    connected_users = np.where(con[:,j]==1)[0]
    for k in range(len(connected_users)):
      x_t_j += x[:,connected_users[k]]
    x_t_j = np.minimum(np.ones((N),int),x_t_j)

    phase[j,:] += x_t_j  
    phase[j] = np.minimum(np.ones((N),int),phase[j]) 
    # new phase
    if np.sum(phase[j]) >= C:
      bit[j,:] = np.zeros((1,N),int) #start new phase
      phase[j,:] = np.zeros((1,N),int)
      
    # file which is not requested but still in the cache
    a1 = np.transpose(np.logical_and(y[j],np.logical_not(np.logical_and(y[j],np.transpose(x_t_j)))))
    a = np.where(a1 == 1)[0]
    # file requested but not in the cache.
    b1 = np.transpose(np.logical_and(np.transpose(x_t_j),np.logical_not(np.logical_and(y[j],np.transpose(x_t_j))))) 
    b = np.where(b1 == 1)[0]
    # file requested available in cache
    c1 = np.logical_and(y[j],x_t_j.reshape(1,N)).reshape(N)
    c = np.where(c1 == 1)[0]
    
    # if requested file is available then bit is set for that file
    for i in range(len(c)):
      bit[j,c[i]] = 1 
    
    # now replace add all b1 files in cache and evict randomly untill end of the face.
    for i in range(len(b)):
      for n in range(N):
        if np.logical_and(y[j,n],np.logical_not(bit[j,n])) == 1:
          y[j,n] = 0
          bit[j,n] = 1
          break
    for i in range(len(b)):
      y[j,b[i]] = 1
              
  new = y.reshape(J*N).copy()
  download = np.sum(np.logical_and(new,np.logical_not(old)))
  return y,bit,download,phase

"""SINGLE CACHE"""

gen_req1 = np.load('/content/drive/My Drive/gen_req.npy')
req1 = np.load('/content/drive/My Drive/req.npy')

I = 1 #users
T = 100000
degree = 1
J = 1 #caches
C = 5
connection = np.array([[1]])
connection.shape

req = req1[:I*T].reshape(I,T)
req

gen_req = gen_req1[:I*T].reshape(I,T)
gen_req

y_LRU = np.zeros((J,N),dtype = int)
y_LFU = np.zeros((J,N),dtype = int)
y_FTPL = np.zeros((J,N),dtype = int)
y_LSTM = np.zeros((J,N),dtype = int)
y_mrk = np.zeros((J,N),dtype = int)
y_mrk[:,:C] = np.ones((J,C),dtype = int)
y_LSTM[:,:C] = np.ones((J,C),dtype = int)
y_FTPL[:,:C] = np.ones((J,C),dtype = int)
y_LRU[:,:C] = np.ones((J,C),dtype = int)
y_LFU[:,:C] = np.ones((J,C),dtype = int)
count = np.zeros((N,I),dtype = int)
reward_LSTM =  np.zeros((T),int)
reward_FTPL =  np.zeros((T),int)
reward_LRU =  np.zeros((T),int)
reward_LFU =  np.zeros((T),int)
reward_mrk =  np.zeros((T),int)
hits_mrk =  []
hits_FTPL =  []
hits_LRU =  []
hits_LFU =  []
hits_LSTM = []
download_FTPL =  []
download_LRU =  []
download_LFU =  []
download_LSTM = []
download_mrk = []
mrk_downloads_slotwise = np.zeros((T),int)
FTPL_downloads_slotwise = np.zeros((T),int)
LFU_downloads_slotwise = np.zeros((T),int)
LRU_downloads_slotwise = np.zeros((T),int)
LSTM_downloads_slotwise = np.zeros((T),int)
req_time = np.zeros((N,I),dtype = int) 
req_time1 = np.zeros((N,I),dtype = int) 
bit = np.zeros((J,N),int)
phase = np.zeros((J,N),int)
normal = random.normal(0,1,[N,I])

for t in range(T):
  x_t1 = np.zeros((N,I),dtype = int)
  x_t = np.zeros((N,I),dtype = int)
  for i in range(I):
    x_t[req[i,t],i] += 1
    x_t1[gen_req[i,t],i] += 1
    count[int(req[i,t]),i] += 1
    req_time[int(req[i,t]),i] = t+1
    req_time1[int(gen_req[i,t]),i] = t+1
  
  ireward_LRU =  np.zeros((I),int)
  ireward_LSTM =  np.zeros((I),int)
  ireward_LFU =  np.zeros((I),int)
  ireward_FTPL =  np.zeros((I),int)
  ireward_mrk =  np.zeros((I),int)
  
  for i in range(I):
    temp1 = np.zeros((N),int)
    temp2 = np.zeros((N),int)
    temp3 = np.zeros((N),int)
    temp4 = np.zeros((N),int)
    temp5 = np.zeros((N),int)

    connected_cache = np.where(connection[i] == 1)[0]
    for k in range(len(connected_cache)):
      temp1 += y_FTPL[connected_cache[k],:]
      temp2 += y_LFU[connected_cache[k],:]
      temp3 += y_LRU[connected_cache[k],:]
      temp4 += y_LSTM[connected_cache[k],:]
      temp5 += y_mrk[connected_cache[k],:]
    ireward_FTPL[i] += np.dot(np.minimum(np.ones(N),temp1),x_t[:,i])
    ireward_LFU[i] += np.dot(np.minimum(np.ones(N),temp2),x_t[:,i])
    ireward_LRU[i] += np.dot(np.minimum(np.ones(N),temp3),x_t[:,i])
    ireward_LSTM[i] += np.dot(np.minimum(np.ones(N),temp4),x_t1[:,i])
    ireward_mrk[i] += np.dot(np.minimum(np.ones(N),temp5),x_t[:,i])


  reward_FTPL[t] =  np.sum(ireward_FTPL)
  reward_LRU[t] =  np.sum(ireward_LRU)
  reward_LFU[t] =  np.sum(ireward_LFU)
  reward_LSTM[t] =  np.sum(ireward_LSTM)
  reward_mrk[t] =  np.sum(ireward_mrk)
  reward_mrkc = np.sum(reward_mrk)
  reward_LSTMc = np.sum(reward_LSTM)
  reward_FTPLc = np.sum(reward_FTPL)
  reward_LRUc = np.sum(reward_LRU)
  reward_LFUc = np.sum(reward_LFU)

  y_LFU, LFU_downloads_slotwise[t] = LFU(y_LFU,x_t,count,connection)
  y_LRU, LRU_downloads_slotwise[t] = LRU(y_LRU,x_t,req_time,connection)
  y_LSTM, LSTM_downloads_slotwise[t] = LRU(y_LSTM,x_t1,req_time1,connection)
  y_mrk, bit, mrk_downloads_slotwise[t], phase = Marker(y_mrk,x_t,bit,connection,phase) 
  eta = round(pow(I,0.75)*pow(2*(np.log(N/C)+1),0.25)*pow((t+1)/(J*degree*C),.5),4)
  perturbed_count=per_count(eta,count,normal)
  old_FTPL = y_FTPL.reshape(J*N)
  add = (-perturbed_count[:,0]).argsort()[:C]
  y_FTPL = np.zeros((J,N),dtype = int)
  for k in range(len(add)):
    y_FTPL[0,int(add[k])] = 1 
  new_FTPL = y_FTPL.reshape(J*N)
  FTPL_downloads_slotwise[t] = (np.sum(np.logical_and(new_FTPL,np.logical_not(old_FTPL))))
 
  download_mrk.append(np.sum(mrk_downloads_slotwise)/(t+1))
  download_FTPL.append(np.sum(FTPL_downloads_slotwise)/(t+1))
  download_LFU.append(np.sum(LFU_downloads_slotwise)/(t+1))
  download_LRU.append(np.sum(LRU_downloads_slotwise)/(t+1))
  download_LSTM.append(np.sum(LSTM_downloads_slotwise)/(t+1))
  hits_mrk.append(reward_mrkc/(t+1))
  hits_LRU.append(reward_LRUc/(t+1))
  hits_LFU.append(reward_LFUc/(t+1))
  hits_FTPL.append(reward_FTPLc/(t+1))
  hits_LSTM.append(reward_LSTMc/(t+1))
  if t %10000 == 0:
    print(t,download_mrk[t],download_FTPL[t],download_LFU[t],download_LRU[t],download_LSTM[t],hits_mrk[t],hits_FTPL[t],hits_LFU[t],hits_LRU[t],hits_LSTM[t])

plt.plot(hits_FTPL,'black',label='FTPL')
plt.plot(hits_LRU,'green',label='LRU')
plt.plot(hits_LFU,'blue',label='LFU')
plt.plot(hits_LSTM,'red',label='LSTM')
plt.plot(hits_mrk,'yellow',label='Marker')
plt.xlabel('T')
plt.ylabel('Total hits/T')
plt.legend()
plt.savefig('hit-rate(I=J=1).png')

plt.plot(download_FTPL,'black',label='FTPL')
plt.plot(download_LRU,'green',label='LRU')
plt.plot(download_LFU,'blue',label='LFU')
plt.plot(download_LSTM,'red',label='LSTM')
plt.plot(download_mrk,'yellow',label='Marker')
plt.xlabel('T')
plt.ylabel('New downloads/T')
plt.legend()
plt.savefig('download-rate(I=J=1).png')

"""I = 5 J = 3 d = 3"""

T = 50000
C = 5
I = 5
J = 3
degree = 3

connection = np.zeros((I,J),dtype = int)
i = 0
for j in range(J):
  x = 0
  while x < degree:
    connection[i,j] = 1
    x += 1
    i += 1
    if i == I:
      i = 0
connection

gen_req1 = np.load('/content/drive/My Drive/gen_req.npy')
req1 = np.load('/content/drive/My Drive/req.npy')
req = req1[20000:]
gen_req = gen_req1[20000:]

req = req.reshape(I,-1)
req.shape

gen_req = gen_req.reshape(I,-1)
gen_req.shape

req

gen_req

y_LRU = np.zeros((J,N),dtype = int)
y_LFU = np.zeros((J,N),dtype = int)
y_FTPL = np.zeros((J,N),dtype = int)
y_LSTM = np.zeros((J,N),dtype = int)
y_mrk = np.zeros((J,N),dtype = int)
y_mrk[:,:C] = np.ones((J,C),dtype = int)
y_LSTM[:,:C] = np.ones((J,C),dtype = int)
y_FTPL[:,:C] = np.ones((J,C),dtype = int)
y_LRU[:,:C] = np.ones((J,C),dtype = int)
y_LFU[:,:C] = np.ones((J,C),dtype = int)
count = np.zeros((N,I),dtype = int)
reward_LSTM =  np.zeros((T),int)
reward_FTPL =  np.zeros((T),int)
reward_LRU =  np.zeros((T),int)
reward_LFU =  np.zeros((T),int)
reward_mrk =  np.zeros((T),int)
hits_mrk =  []
hits_FTPL =  []
hits_LRU =  []
hits_LFU =  []
hits_LSTM = []
download_FTPL =  []
download_LRU =  []
download_LFU =  []
download_LSTM = []
download_mrk = []
mrk_downloads_slotwise = np.zeros((T),int)
FTPL_downloads_slotwise = np.zeros((T),int)
LFU_downloads_slotwise = np.zeros((T),int)
LRU_downloads_slotwise = np.zeros((T),int)
LSTM_downloads_slotwise = np.zeros((T),int)
req_time = np.zeros((N,I),dtype = int) 
req_time1 = np.zeros((N,I),dtype = int) 
bit = np.zeros((J,N),int)
phase = np.zeros((J,N),int)
normal = random.normal(0,1,[N,I])

for t in range(T):
  x_t = np.zeros((N,I),dtype = int)
  x_t1 = np.zeros((N,I),dtype = int)
  for i in range(I):
    x_t[req[i,t],i] += 1
    x_t1[gen_req[i,t],i] += 1
    count[int(req[i,t]),i] += 1
    req_time[int(req[i,t]),i] = t+1
    req_time1[int(gen_req[i,t]),i] = t+1
  
  ireward_LRU =  np.zeros((I),int)
  ireward_LSTM =  np.zeros((I),int)
  ireward_LFU =  np.zeros((I),int)
  ireward_FTPL =  np.zeros((I),int)
  ireward_mrk =  np.zeros((I),int)
  
  for i in range(I):
    temp1 = np.zeros((N),int)
    temp2 = np.zeros((N),int)
    temp3 = np.zeros((N),int)
    temp4 = np.zeros((N),int)
    temp5 = np.zeros((N),int)

    connected_cache = np.where(connection[i] == 1)[0]
    for k in range(len(connected_cache)):
      temp1 += y_FTPL[connected_cache[k],:]
      temp2 += y_LFU[connected_cache[k],:]
      temp3 += y_LRU[connected_cache[k],:]
      temp4 += y_LSTM[connected_cache[k],:]
      temp5 += y_mrk[connected_cache[k],:]
    ireward_FTPL[i] += np.dot(np.minimum(np.ones(N),temp1),x_t[:,i])
    ireward_LFU[i] += np.dot(np.minimum(np.ones(N),temp2),x_t[:,i])
    ireward_LRU[i] += np.dot(np.minimum(np.ones(N),temp3),x_t[:,i])
    ireward_LSTM[i] += np.dot(np.minimum(np.ones(N),temp4),x_t1[:,i])
    ireward_mrk[i] += np.dot(np.minimum(np.ones(N),temp5),x_t[:,i])

  reward_FTPL[t] =  np.sum(ireward_FTPL)
  reward_LRU[t] =  np.sum(ireward_LRU)
  reward_LFU[t] =  np.sum(ireward_LFU)
  reward_LSTM[t] =  np.sum(ireward_LSTM)
  reward_mrk[t] =  np.sum(ireward_mrk)
  reward_mrkc = np.sum(reward_mrk)
  reward_LSTMc = np.sum(reward_LSTM)
  reward_FTPLc = np.sum(reward_FTPL)
  reward_LRUc = np.sum(reward_LRU)
  reward_LFUc = np.sum(reward_LFU)

  [y_LFU,LFU_downloads_slotwise[t]] = LFU(y_LFU,x_t,count,connection)
  [y_LRU,LRU_downloads_slotwise[t]] = LRU(y_LRU,x_t,req_time,connection)
  [y_LSTM,LSTM_downloads_slotwise[t]] = LRU(y_LSTM,x_t1,req_time1,connection)
  [y_mrk,bit,mrk_downloads_slotwise[t],phase] = Marker(y_mrk,x_t,bit,connection,phase) 

  eta = round(pow(I,0.75)*pow(2*(np.log(N/C)+1),0.25)*pow((t+1)/(J*degree*C),0.5),4)
  perturbed_count=per_count(eta,count,normal)
  old_FTPL = y_FTPL.reshape(J*N).copy()
  [y_FTPL,Z] = Greedy(connection,perturbed_count) 
  new_FTPL = y_FTPL.reshape(J*N).copy()
  FTPL_downloads_slotwise[t] = np.sum(np.logical_and(new_FTPL,np.logical_not(old_FTPL)))

  download_mrk.append(np.sum(mrk_downloads_slotwise)/(t+1))
  download_FTPL.append(np.sum(FTPL_downloads_slotwise)/(t+1))
  download_LFU.append(np.sum(LFU_downloads_slotwise)/(t+1))
  download_LRU.append(np.sum(LRU_downloads_slotwise)/(t+1))
  download_LSTM.append(np.sum(LSTM_downloads_slotwise)/(t+1))
  hits_mrk.append(reward_mrkc/(t+1))
  hits_LRU.append(reward_LRUc/(t+1))
  hits_LFU.append(reward_LFUc/(t+1))
  hits_FTPL.append(reward_FTPLc/(t+1))
  hits_LSTM.append(reward_LSTMc/(t+1))

  if t %1000 == 0:
    print(t,download_mrk[t],download_FTPL[t],download_LFU[t],download_LRU[t],download_LSTM[t],hits_mrk[t],hits_FTPL[t],hits_LFU[t],hits_LRU[t],hits_LSTM[t])

plt.plot(hits_FTPL,'black',label='FTPL')
plt.plot(hits_LRU,'green',label='LRU')
plt.plot(hits_LFU,'blue',label='LFU')
plt.plot(hits_LSTM,'red',label='LSTM')
plt.plot(hits_mrk,'yellow',label='Marker')
plt.xlabel('T')
plt.ylabel('total hits/T')
plt.legend()
plt.savefig('hit-rate(I=5 J=3 d=3).png')

plt.plot(download_mrk,'yellow',label='Marker')
plt.plot(download_FTPL,'black',label='FTPL')
plt.plot(download_LRU,'green',label='LRU')
plt.plot(download_LFU,'blue',label='LFU')
plt.plot(download_LSTM,'red',label='LSTM')
plt.xlabel('T')
plt.ylabel('New downloads')
plt.legend()
plt.savefig('download-rate(I=5 J=3 d=3).png')

"""I = 15 J = 10 d = 7"""

I = 10
J = 4
C = 10
degree = 3
normal = random.normal(0,1,[N,I])
T = 50000

connection = np.zeros((I,J),dtype = int)
i = 0
for j in range(J):
  x = 0
  while x < degree:
    connection[i,j] = 1
    x += 1
    i += 1
    if i == I:
      i = 0
connection

gen_req1 = np.load('/content/drive/My Drive/gen_req.npy')
req1 = np.load('/content/drive/My Drive/req.npy')
req1 = req1[20000:]
gen_req1 = gen_req1[20000:]

req = req1.reshape(I,-1)
req.shape

gen_req = gen_req1.reshape(I,-1)
gen_req.shape

y_LRU = np.zeros((J,N),dtype = int)
y_LFU = np.zeros((J,N),dtype = int)
y_FTPL = np.zeros((J,N),dtype = int)
y_LSTM = np.zeros((J,N),dtype = int)
y_mrk = np.zeros((J,N),dtype = int)
y_mrk[:,:C] = np.ones((J,C),dtype = int)
y_LSTM[:,:C] = np.ones((J,C),dtype = int)
y_FTPL[:,:C] = np.ones((J,C),dtype = int)
y_LRU[:,:C] = np.ones((J,C),dtype = int)
y_LFU[:,:C] = np.ones((J,C),dtype = int)
count = np.zeros((N,I),dtype = int)
reward_LSTM =  np.zeros((T),int)
reward_FTPL =  np.zeros((T),int)
reward_LRU =  np.zeros((T),int)
reward_LFU =  np.zeros((T),int)
reward_mrk =  np.zeros((T),int)
hits_mrk =  []
hits_FTPL =  []
hits_LRU =  []
hits_LFU =  []
hits_LSTM = []
download_FTPL =  []
download_LRU =  []
download_LFU =  []
download_LSTM = []
download_mrk = []
mrk_downloads_slotwise = np.zeros((T),int)
FTPL_downloads_slotwise = np.zeros((T),int)
LFU_downloads_slotwise = np.zeros((T),int)
LRU_downloads_slotwise = np.zeros((T),int)
LSTM_downloads_slotwise = np.zeros((T),int)
req_time = np.zeros((N,I),dtype = int) 
req_time1 = np.zeros((N,I),dtype = int) 
bit = np.zeros((J,N),int)
phase = np.zeros((J,N),int)
for t in range(T):
  x_t1 = np.zeros((N,I),dtype = int)
  x_t = np.zeros((N,I),dtype = int)
  for i in range(I):
    x_t[req[i,t],i] += 1
    x_t1[gen_req[i,t],i] += 1
    count[int(req[i,t]),i] += 1
    req_time[int(req[i,t]),i] = t+1
    req_time1[int(gen_req[i,t]),i] = t+1
  
  ireward_LRU =  np.zeros((I),int)
  ireward_LSTM =  np.zeros((I),int)
  ireward_LFU =  np.zeros((I),int)
  ireward_FTPL =  np.zeros((I),int)
  ireward_mrk =  np.zeros((I),int)
  
  for i in range(I):
    temp1 = np.zeros((N),int)
    temp2 = np.zeros((N),int)
    temp3 = np.zeros((N),int)
    temp4 = np.zeros((N),int)
    temp5 = np.zeros((N),int)

    connected_cache = np.where(connection[i] == 1)[0]
    for k in range(len(connected_cache)):
      temp1 += y_FTPL[connected_cache[k],:]
      temp2 += y_LFU[connected_cache[k],:]
      temp3 += y_LRU[connected_cache[k],:]
      temp4 += y_LSTM[connected_cache[k],:]
      temp5 += y_mrk[connected_cache[k],:]
    ireward_FTPL[i] += np.dot(np.minimum(np.ones(N),temp1),x_t[:,i])
    ireward_LFU[i] += np.dot(np.minimum(np.ones(N),temp2),x_t[:,i])
    ireward_LRU[i] += np.dot(np.minimum(np.ones(N),temp3),x_t[:,i])
    ireward_LSTM[i] += np.dot(np.minimum(np.ones(N),temp4),x_t1[:,i])
    ireward_mrk[i] += np.dot(np.minimum(np.ones(N),temp5),x_t[:,i])

  reward_FTPL[t] =  np.sum(ireward_FTPL)
  reward_LRU[t] =  np.sum(ireward_LRU)
  reward_LFU[t] =  np.sum(ireward_LFU)
  reward_LSTM[t] =  np.sum(ireward_LSTM)
  reward_mrk[t] =  np.sum(ireward_mrk)
  reward_mrkc = np.sum(reward_mrk)
  reward_LSTMc = np.sum(reward_LSTM)
  reward_FTPLc = np.sum(reward_FTPL)
  reward_LRUc = np.sum(reward_LRU)
  reward_LFUc = np.sum(reward_LFU)

  [y_LFU,LFU_downloads_slotwise[t]] = LFU(y_LFU,x_t,count,connection)
  [y_LRU,LRU_downloads_slotwise[t]] = LRU(y_LRU,x_t,req_time,connection)
  [y_LSTM,LSTM_downloads_slotwise[t]] = LRU(y_LSTM,x_t1,req_time1,connection)
  [y_mrk,bit,mrk_downloads_slotwise[t],phase] = Marker(y_mrk,x_t,bit,connection,phase) 

  eta = round(I*pow(4*pi*np.log(N*I),-.25)*pow((t+1)/(J*degree*C),.5),4)
  perturbed_count=per_count(eta,count,normal)
  old_FTPL = y_FTPL.reshape(J*N).copy()
  [y_FTPL,Z] = Greedy(connection,perturbed_count) 
  new_FTPL = y_FTPL.reshape(J*N).copy()
  FTPL_downloads_slotwise[t] = (np.sum(np.logical_and(new_FTPL,np.logical_not(old_FTPL))))

  download_mrk.append(np.sum(mrk_downloads_slotwise)/(t+1))
  download_FTPL.append(np.sum(FTPL_downloads_slotwise)/(t+1))
  download_LFU.append(np.sum(LFU_downloads_slotwise)/(t+1))
  download_LRU.append(np.sum(LRU_downloads_slotwise)/(t+1))
  download_LSTM.append(np.sum(LSTM_downloads_slotwise)/(t+1))
  hits_mrk.append(reward_mrkc/(t+1))
  hits_LRU.append(reward_LRUc/(t+1))
  hits_LFU.append(reward_LFUc/(t+1))
  hits_FTPL.append(reward_FTPLc/(t+1))
  hits_LSTM.append(reward_LSTMc/(t+1))

  if t %1000 == 0:
    print(t,download_mrk[t],download_FTPL[t],download_LFU[t],download_LRU[t],download_LSTM[t],hits_mrk[t],hits_FTPL[t],hits_LFU[t],hits_LRU[t],hits_LSTM[t])

plt.plot(hits_FTPL,'black',label='FTPL')
plt.plot(hits_LRU,'green',label='LRU')
plt.plot(hits_LFU,'blue',label='LFU')
plt.plot(hits_LSTM,'red',label='LSTM')
plt.plot(hits_mrk,'yellow',label='Marker')
plt.xlabel('T')
plt.ylabel('total hits')
plt.legend()
plt.savefig('hit-rate(I=10 J=4 d=3).png')

plt.plot(download_FTPL,'black',label='FTPL')
plt.plot(download_LRU,'green',label='LRU')
plt.plot(download_LFU,'blue',label='LFU')
plt.plot(download_LSTM,'red',label='LSTM')
plt.plot(download_mrk,'yellow',label='Marker')
plt.xlabel('T')
plt.ylabel('new downloads')
plt.legend()
plt.savefig('download-rate(I=10 J=4 d=3).png')

